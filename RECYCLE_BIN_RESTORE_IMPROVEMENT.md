# 回收站还原逻辑优化

## 修改日期
2024-12-04

## 问题描述

在复杂的文件夹层级删除和还原场景中，存在以下问题：

### 场景示例
```
文件夹
  └── 子文件夹
        ├── 文件A
        └── 文件B
  └── 文件C
```

**删除顺序：**
1. 删除文件A
2. 删除子文件夹（包含文件B）
3. 删除文件夹（包含文件C）

**还原顺序和问题：**
1. 还原文件A → 自动创建"文件夹"和"子文件夹"
2. 还原子文件夹 → 文件夹已存在，导致冲突或覆盖
3. 还原文件夹 → 文件夹已存在，导致冲突或覆盖

## 解决方案

### 1. 添加辅助函数

#### `generateUniqueFolderName(baseName, owner, parentId)`
- 生成唯一的文件夹名称
- 如果名称已存在，自动添加序号：`文件夹(1)`, `文件夹(2)`, `文件夹(3)`...

#### `findOrCreateFolder(folderInfo, owner)`
- 智能查找或创建文件夹
- 返回 `{ folder, isNew }` 表示是否新创建
- 查找顺序：
  1. 通过原始ID查找
  2. 通过物理路径查找
  3. 如果不存在则创建

### 2. 修改还原逻辑

#### 还原文件夹
```javascript
if (文件夹已存在) {
    // 创建带序号的新文件夹
    uniqueName = generateUniqueFolderName(原名称, owner, parentId);
    创建新文件夹(uniqueName);
    恢复文件到新文件夹;
} else {
    // 创建原名称的文件夹
    创建文件夹(原名称);
    恢复文件到文件夹;
}
```

#### 还原文件
```javascript
if (目标文件夹不存在) {
    // 使用 findOrCreateFolder 自动创建
    targetFolder = findOrCreateFolder(文件夹信息);
}
恢复文件到目标文件夹;
```

## 新的还原行为

### 场景1：按顺序还原
1. 还原文件A → 创建"文件夹"和"子文件夹"，恢复文件A
2. 还原子文件夹 → 创建"子文件夹(1)"，恢复文件B
3. 还原文件夹 → 创建"文件夹(1)"，恢复文件C

**结果：**
```
文件夹
  └── 子文件夹
        └── 文件A
文件夹(1)
  └── 子文件夹(1)
        └── 文件B
  └── 文件C
```

### 场景2：先还原文件夹
1. 还原文件夹 → 创建"文件夹"，恢复文件C
2. 还原子文件夹 → 创建"子文件夹"，恢复文件B
3. 还原文件A → 恢复到现有"子文件夹"

**结果：**
```
文件夹
  └── 子文件夹
        ├── 文件A
        └── 文件B
  └── 文件C
```

## 优势

1. **避免冲突**：文件夹已存在时自动创建带序号的新文件夹
2. **数据完整**：所有文件都能正确还原，不会丢失
3. **灵活性**：支持任意顺序的还原操作
4. **用户友好**：清晰的命名规则，用户可以理解发生了什么

## 修改的文件

- `backend/src/routes/recycleBinRoutes.js`
  - 添加 `generateUniqueFolderName()` 函数
  - 添加 `findOrCreateFolder()` 函数
  - 修改文件夹还原逻辑
  - 修改文件还原逻辑

## API 变更

### POST /api/folders/trash/restore/:itemId

**响应消息变化：**
- 文件夹已存在时：`文件夹已恢复为"文件夹(1)"（包含 X 个文件）`
- 文件夹不存在时：`文件夹已恢复（包含 X 个文件）`

## 测试建议

1. 创建多层文件夹结构
2. 按不同顺序删除文件和文件夹
3. 按不同顺序还原
4. 验证所有文件都能正确还原
5. 验证文件夹命名是否正确

## 注意事项

- 带序号的文件夹表示这是重复还原的结果
- 用户可以手动合并或重命名这些文件夹
- 物理文件不会重复，每个文件都有唯一的存储路径
